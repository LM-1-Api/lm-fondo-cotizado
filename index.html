<script>
  // trae los precios desde TU backend en Vercel
  async function loadSpot() {
    try {
      const r = await fetch("/api/spot");
      const data = await r.json();
      if (data.gold && data.gold.price) {
        document.getElementById("gold-price").textContent = "$" + data.gold.price.toFixed(2);
        document.getElementById("tk-gold").textContent = "$" + data.gold.price.toFixed(2);
      }
      if (data.silver && data.silver.price) {
        document.getElementById("silver-price").textContent = "$" + data.silver.price.toFixed(2);
        document.getElementById("tk-silver").textContent = "$" + data.silver.price.toFixed(2);
      }
      return data;
    } catch (e) {
      console.log("error spot", e);
      return null;
    }
  }

  // genera velas "fake" a partir de un precio base
  function makeCandlesFromSpot(price, points = 40, volatility = 0.0007) {
    const now = Math.floor(Date.now() / 1000);
    const out = [];
    let last = price;
    for (let i = points; i >= 0; i--) {
      const t = now - i * 60;
      const delta = (Math.random() - 0.5) * (price * volatility);
      const open = last;
      const close = last + delta;
      const high = Math.max(open, close) + price * (volatility * 0.6);
      const low = Math.min(open, close) - price * (volatility * 0.6);
      out.push({ time: t, open, high, low, close });
      last = close;
    }
    return out;
  }

  // crea los dos charts
  const goldChart = LightweightCharts.createChart(document.getElementById("chart-gold"), {
    layout: { background: { color: "#1a1a1a" }, textColor: "#fff" },
    grid: {
      vertLines: { color: "rgba(198,166,99,0.05)" },
      horzLines: { color: "rgba(198,166,99,0.05)" }
    },
    rightPriceScale: { borderColor: "rgba(198,166,99,0.3)" },
    timeScale: { borderColor: "rgba(198,166,99,0.3)" },
    crosshair: { mode: 0 }
  });
  const goldSeries = goldChart.addCandlestickSeries({
    upColor: "#00c853",
    downColor: "#d32f2f",
    borderUpColor: "#00c853",
    borderDownColor: "#d32f2f",
    wickUpColor: "#00c853",
    wickDownColor: "#d32f2f"
  });

  const silverChart = LightweightCharts.createChart(document.getElementById("chart-silver"), {
    layout: { background: { color: "#1a1a1a" }, textColor: "#fff" },
    grid: {
      vertLines: { color: "rgba(198,166,99,0.05)" },
      horzLines: { color: "rgba(198,166,99,0.05)" }
    },
    rightPriceScale: { borderColor: "rgba(198,166,99,0.3)" },
    timeScale: { borderColor: "rgba(198,166,99,0.3)" },
    crosshair: { mode: 0 }
  });
  const silverSeries = silverChart.addCandlestickSeries({
    upColor: "#00c853",
    downColor: "#d32f2f",
    borderUpColor: "#00c853",
    borderDownColor: "#d32f2f",
    wickUpColor: "#00c853",
    wickDownColor: "#d32f2f"
  });

  // vamos a guardar los últimos precios para recalcular rápido
  const lastPrices = {
    gold: 2350,
    silver: 28
  };

  // función que aplica timeframe segun metal
  function applyTimeframe(metal, tf) {
    // definimos “sensación” de timeframe
    let points = 40;
    let vol = 0.0007;

    switch (tf) {
      case "5m":
        points = 60;
        vol = 0.0005;
        break;
      case "15m":
        points = 80;
        vol = 0.0004;
        break;
      case "1h":
        points = 96;
        vol = 0.00035;
        break;
      case "4h":
        points = 60;
        vol = 0.00025;
        break;
      case "1d":
        points = 30;
        vol = 0.00018;
        break;
      default: // 1m
        points = 40;
        vol = 0.0007;
    }

    if (metal === "XAU") {
      const data = makeCandlesFromSpot(lastPrices.gold, points, vol);
      goldSeries.setData(data);
    } else {
      const data = makeCandlesFromSpot(lastPrices.silver, points, vol);
      silverSeries.setData(data);
    }
  }

  // listeners de los botones
  document.querySelectorAll(".tf-row").forEach(row => {
    const metal = row.getAttribute("data-metal");
    row.querySelectorAll(".tf-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        // sacar active
        row.querySelectorAll(".tf-btn").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        const tf = btn.getAttribute("data-tf");
        applyTimeframe(metal, tf);
      });
    });
  });

  // iniciar
  (async () => {
    const spot = await loadSpot();
    if (spot && spot.gold) {
      lastPrices.gold = spot.gold.price;
      applyTimeframe("XAU", "1m");
    } else {
      applyTimeframe("XAU", "1m");
    }

    if (spot && spot.silver) {
      lastPrices.silver = spot.silver.price;
      applyTimeframe("XAG", "1m");
    } else {
      applyTimeframe("XAG", "1m");
    }
  })();

  // refrescar spot cada 60s, pero mantener el timeframe que el user eligió
  setInterval(async () => {
    const spot = await loadSpot();
    if (spot && spot.gold) lastPrices.gold = spot.gold.price;
    if (spot && spot.silver) lastPrices.silver = spot.silver.price;

    // ver qué timeframe está activo en cada uno
    const goldActive = document.querySelector('.tf-row[data-metal="XAU"] .tf-btn.active')?.getAttribute("data-tf") || "1m";
    const silverActive = document.querySelector('.tf-row[data-metal="XAG"] .tf-btn.active')?.getAttribute("data-tf") || "1m";

    applyTimeframe("XAU", goldActive);
    applyTimeframe("XAG", silverActive);
  }, 60000);
</script>
